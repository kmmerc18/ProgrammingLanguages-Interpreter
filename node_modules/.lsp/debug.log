Hello - from /Users/kim/.vscode/extensions/jaredly.reason-vscode-1.7.13/bin.native
Previous log location: /var/folders/p5/sjy06jv57qv_nxrk5f8n92kh0000gn/T/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re","languageId":"reason","version":1,"text":"// 139ba267302516bcc9e9e23141d94ac04cd56a91\n\n// OCAMLRUNPARAM=b ./interpreter.exe xxx.cl-type\n\nopen Ast1;\n\n// make a mutable variable to keep track of the number of activations for stack overflow\nlet activations = ref(0);\n\n// update the number of activation records for each currently processing dispatch/ new object\nlet update = (increase: bool, lineno: int) => {\n    // increase - flag to indicate increment or decrement of activations\n    switch(increase) {\n        | true => {\n            activations := activations^ + 1;\n\n            // if increasing, check for a potential stack overflow\n            if(activations^ >= 1000) {\n                print_endline(\"ERROR: \" ++ string_of_int(lineno) ++ \": Exception: stack overflow\");\n                exit(1);\n            };\n        };\n        | false => {\n            activations := activations^ - 1;\n        }\n    };\n};\n\n// ensure the correct number of command line arguments\nif (Array.length(Sys.argv) != 2) {\n    Printf.printf(\"usage: ./interpreter cl-type-file\\n\");\n};\n\n// command line arguments verified by this point\n// open cl-type file for reading\nlet ast_file = open_in(Sys.argv[1]);\n\n// get the maps from cl-type file\nlet (class_map, imp_map, parent_map) = read_cl_type_file(ast_file);\n\n// type for locations (just represented with ints)\ntype location = int;\n\n// variant types for the possible values in COOL\ntype value = \n    | Void \n    | Bool(bool)\n    | Int(int)\n    | String(int, string)  // length, string_const\n    | Dynamic(string, list((string, location)), location);  // type, list((name, location) tuples)\n\n// helper function to get the type of an object\nlet getType = (obj): string => {\n    switch(obj) {\n    | Void => \"Void\"\n    | Bool(_) => \"Bool\"\n    | Int(_) => \"Int\"\n    | String(_, _) => \"String\"\n    | Dynamic(typ, _, _) => typ\n    }\n}\n\n// create a type for location maps (store)\nmodule OrderedLocation = {\n    type t = location;\n    let compare = compare;\n};\nmodule LocationMap = Map.Make(OrderedLocation); // store map\n\n// use with environment\nmodule StringMap = Map.Make(String); // environment map\n\n// creating a new location that is currently unused in a given store\nlet new_loc = (sto): location => {\n    // get max value, may be none\n    let mbinding = LocationMap.max_binding_opt(sto);  \n\n    // figure out if max binding is none or tuple\n    let loc = switch(mbinding) {  \n        |None => 0\n        |Some((loc, _)) => loc  // only care about loc\n    }\n\n    // increment to get the next location\n    loc + 1;\n}\n\n// helper for fold_left to insert items into the store \nlet fill_sto_entry = (sto, loc, value) => {\n    LocationMap.add(loc, value, sto);\n};\n\n// helper for fold_left to insert items into the environment \nlet fill_env_entry = (env, name, loc) => {\n    StringMap.add(name, loc, env);\n};\n\n// return the value and a new store that maps locations to values\nlet rec eval_expr = (so, env, sto, expr): (value, LocationMap.t(value)) => {\n\n    // decompose expr contents\n    let(line, typ_expr, exp) = expr;\n    \n    // INTERNAL HELPERS\n    let rec dispatch_process = (args, sto, lst): (list(value), LocationMap.t(value)) => {\n\n        // create list to store values \n        switch(args) {\n            | [hd,...tl] => {\n                let(v, sto2) = eval_expr(so, env, sto, hd);  // get value and location map for this head\n                let lst = lst @ [v];  // add this value to list\n                dispatch_process(tl, sto2, lst);  // eval tail\n            }\n            | [] => (lst, sto);\n        };\n    };\n\n    // make a list of n locations\n    let rec get_l = (n, sto, lst) => {\n\n        // create list to store values \n        switch(n) {\n            | 0 => lst;\n            | _ => {\n\n                // get a new location\n                let loc = new_loc(sto);\n\n                // put the new location in the store\n                let sto2 = LocationMap.add(loc, Void, sto);\n                \n                // append the new location to the location list\n                let lst = lst @ [loc];\n\n                // get another new location with the new store \n                get_l(n - 1, sto2, lst);\n            }\n        };\n    };\n\n    // get the default values for each attr given a type\n    let get_default_vals = (acc, typ) => {\n        switch(typ) {\n            | \"String\" => acc @ [String(0, \"\")];\n            | \"Int\" => acc @ [Int(0)];\n            | \"Bool\" =>  acc @ [Bool(false)];\n            | _ => acc @ [Void];\n        }\n    };\n\n    // pass in two Int values and the aritmatic operation to evaluate\n    let compute_arithmetic = (x, y, op, divide): (value, LocationMap.t(value)) => {\n\n        let (v_x, sto2) = eval_expr(so, env, sto, x);\n        let (v_y, sto3) = eval_expr(so, env, sto2, y);\n\n        switch (v_x, v_y) {\n            | (Int(i), Int(j)) => {\n                if (!divide) {\n                    (Int(op(i, j)), sto3);\n                } else {\n                    if (j == 0) {\n                            print_endline(\"ERROR: \" ++ string_of_int(line) ++  \": Exception: division by zero\");\n                            exit(1);\n                    } else {\n                        (Int(i/j), sto3);\n                    };\n                }\n            };\n            | _ => {\n                print_endline(\"not ints\");\n                exit(1);\n            };\n        };\n    };\n\n    // EVALUATE EXPRESSIONS\n    switch(exp) {\n        | Identifer(id) => {\n            // get name\n            let(_, name) = id;\n\n            // get the associated value\n            let v = switch(name) {\n                | \"self\" => so; // just the self object if self\n                | _ => {\n                    // Search environment by name\n                    let loc = switch(StringMap.find(name, env)) {\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find id\"); 1;\n                    };\n\n                    // Search store by location\n                    switch(LocationMap.find(loc, sto)){\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find value (id)\" ++ name ++ string_of_int(line)); exit(1);\n                    };\n                };\n            };\n\n            // return the value and the new store\n            (v, sto);\n        };\n        | Assign(id, expr) => {\n            let(_, name) = id;\n            // evaluate the expression\n            let (v1, sto2) = eval_expr(so, env, sto, expr);\n            \n            // get the location of the identifier and store the value there\n            let loc = switch(StringMap.find(name, env)){\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find id (assign)\" ++ name); exit(1);\n                    };\n            \n            let sto3 = LocationMap.add(loc, v1, sto2);\n\n            // return the value and the new store\n            (v1, sto3);\n        }\n        | DynamicDispatch(e0, f, args) => {\n            // increment the activations counter\n            update(true, line);\n\n            // get a list of values from evaluating the args\n            let(lst, sto2) = dispatch_process(args, sto, []); // v1-vn\n\n            // evaluate e0 to get the object v0\n            let(v0, sto3) = eval_expr(so, env, sto2, e0);\n            \n            // get the type of v0\n            let typ = getType(v0);\n\n            // get attr info from v0\n            let v0_info = switch(v0) {\n                // for non dynamic types we give the name of the type and an empty arg list\n                    // all methods relating to these will be handled in an internal exp\n                | Void => {\n                    print_endline(\"ERROR: \" ++ string_of_int(line) ++  \": Exception: dispatch on void\");\n                    exit(1);\n                };\n                | Bool(_) => (\"Bool\", [])\n                | Int(_) => (\"Int\", [])\n                | String(_, _) => (\"String\", []);\n                | Dynamic(name, attr_tuple, _) => (name, attr_tuple);\n            }\n            \n            // break up the info - type, list(name, loc)\n            let(_, attr_tuple) = v0_info; \n        \n            // use the type to find the list of methods of v0\n            let(methods) = switch(List.assoc(typ, imp_map)) {\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find methods (dynamic)\"); exit(1);\n                    };\n\n            // use the function name to get the method information\n            let(_, f_name) = f;\n\n            let((formals, _, body)) = switch(List.assoc(f_name, methods)) {\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find method information (dynamic)\"); exit(1);\n                    };\n             \n            // list of new locations for the formals\n            let lx = get_l(List.length(lst), sto3, []);  \n\n            // decompose\n            let(attrs, la) = List.split(attr_tuple);  \n            \n            // insert the values and new locations to the store\n            let sto4 = List.fold_left2(fill_sto_entry, sto3, lx, lst);\n\n            // insert the attr names and their locations in the environment\n            let env2 = List.fold_left2(fill_env_entry, env, attrs, la);\n\n            // insert the formal names and the new locations in then environment\n            let env3 = List.fold_left2(fill_env_entry, env2, formals, lx);\n\n            // save the results of eval body - returns final (value, store): (v, S_n+3)\n            let tup = eval_expr(v0, env3, sto4, body);  \n\n            // decrement activation counter\n            update(false, line);\n\n            // return the eval tuple\n            tup;\n        }\n        | StaticDispatch(e0, typ, m, args) => {\n            // increment activations counter\n            update(true, line);\n\n            let(lst, sto2) = dispatch_process(args, sto, []);\n            let(v0, sto3) = eval_expr(so, env, sto2, e0);\n            let v0_info = switch(v0) {\n                | Void => {\n                    print_endline(\"ERROR: \" ++ string_of_int(line) ++  \": Exception: dispatch on void\");\n                    exit(1);\n                };\n                | Bool(_) => (\"Bool\", [])\n                | Int(_) => (\"Int\", [])\n                | String(_, _) => (\"String\", []);\n                | Dynamic(name, attr_tuple, _) => (name, attr_tuple);\n            }\n            // type, list(name, loc)\n            let(_, attr_tuple) = v0_info;\n            let (_, static_typ) = typ;\n\n            // use the type to find the list of methods of v0\n            let(methods) = switch(List.assoc(static_typ, imp_map)) {\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find methods (static)\"); exit(1);\n                    };\n\n            // use the function name to get the method information\n            let(_, m_name) = m;\n            let((formals, _, body)) = switch(List.assoc(m_name, methods)) {\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find method info (static)\"); exit(1);\n                    };\n            \n            // list of new locations for the formals\n            let lx = get_l(List.length(lst), sto3, []);\n\n            // decompose\n            let(attrs, la) = List.split(attr_tuple);  \n            \n            // same as dynamic\n            let sto4 = List.fold_left2(fill_sto_entry, sto, lx, lst);\n            let env2 = List.fold_left2(fill_env_entry, env, attrs, la);\n            let env3 = List.fold_left2(fill_env_entry, env2, formals, lx);\n            \n            // save the results of eval body - returns final (value, store): (v, S_n+3)\n            let tup = eval_expr(v0, env3, sto4, body);  \n\n            // decrement activation counter\n            update(false, line);\n\n            // return the eval tuple\n            tup;\n        }\n        | SelfDispatch(f, args) => {\n            // increment activations counter\n            update(true, line);\n\n            // get the values\n            let(lst, sto2) = dispatch_process(args, sto, []);\n            // get the type of the object \n            let self_type = getType(so);\n\n            // get the attributes from the object\n            let so_info = switch(so) {\n                // for string we should give the string value a location at some point\n                | Void => (\"Void\", []);\n                | Bool(_) => (\"Bool\", []);\n                | Int(_) => (\"Int\", []);\n                | String(_, _) => (\"String\", []);\n                | Dynamic(name, attr_tuple, _) => (name, attr_tuple);\n            }\n            // type, list(name, loc)\n            let(_, attr_tuple) = so_info;\n\n            // use the type to find the list of methods of v0\n            let(methods) = switch(List.assoc(self_type, imp_map)) {\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find method (self)\"); exit(1);\n                    };\n\n            // use the function name to get the method information\n            let(_, f_name) = f;\n            let((formals, _, body)) = switch(List.assoc(f_name, methods)){\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find method info (self)\"); exit(1);\n                    };\n            \n            // list of new locations for the formals\n            let lx = get_l(List.length(lst), sto2, []);\n\n            // decompose\n            let(attrs, la) = List.split(attr_tuple);  \n            \n            // same as previous dispatches\n            let sto3 = List.fold_left2(fill_sto_entry, sto, lx, lst);\n            let env2 = List.fold_left2(fill_env_entry, env, attrs, la);\n            let env3 = List.fold_left2(fill_env_entry, env2, formals, lx);\n            \n            // save the results of eval body - returns final (value, store): (v, S_n+3)\n            let tup = eval_expr(so, env3, sto3, body);   \n\n            // decrement activation counter\n            update(false, line);\n\n            // return the eval tuple\n            tup;\n        }\n        | If(pred, then_exp, else_exp) => {\n            // evaluate the predicate\n            let (v1, sto2) = eval_expr(so, env, sto, pred);\n\n            // evaluate the expression depending on the result of the predicate\n                // returns the value and new store of the eval'd expr\n            switch(v1) {\n                | Bool(true) => eval_expr(so, env, sto2, then_exp);\n                | Bool(false) => eval_expr(so, env, sto2, else_exp);\n                | _ => {print_endline(\"400\"); exit(1)};\n            } \n        }\n        | While(pred, body) => {\n            // evaluate the predicate\n            let (v1, sto2) = eval_expr(so, env, sto, pred);\n\n            // evaluate the expression depending on the result of the predicate\n                // returns the value and new store of the eval'd expr\n            switch(v1) {\n                | Bool(true) => {\n                    // evaluate the body\n                    let(_, sto3) = eval_expr(so, env, sto2, body);\n\n                    // make a new while to evaluate\n                    let while_exp = (line, typ_expr, While(pred, body));\n\n                    // evaluate the new while with the new store\n                    eval_expr(so, env, sto3, while_exp);\n                }\n                | Bool(false) => (Void, sto2);\n                | _ => {print_endline(\"421\"); exit(1)};\n            }\n        }\n        | Block(expr_list) => {\n            // helper to get the value and new store from an expr\n            let eval_seq = (acc, expr) => {\n                let (_, store) = acc;\n                let(v_new, sto2) = eval_expr(so, env, store, expr);\n                (v_new, sto2);\n            };\n            // go through all the expressions and get the store and values\n            // use a void to start the acc bc it doesnt impact the eval\n            List.fold_left(eval_seq, (Void, sto), expr_list);\n        };\n        | New(id) => {\n            // increment activations counter\n            update(true, line);\n            \n            // get type from id\n            let(_, typ) = id;\n\n            // determine type\n            let t0 = switch(typ){\n                | \"SELF_TYPE\" => getType(so);\n                | _ => typ;\n            };\n\n            // get the attributes from the class map\n            let attrs = switch(List.assoc(t0, class_map)){\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find attrs (new)\"); exit(1);\n                    }; // list(name, type, expr)\n            \n            // create new locations to put attrs\n            let li = get_l(List.length(attrs), sto, []);  \n\n            // helpers to extra information from the attributes\n            // get names of attr\n            let get_name = (acc, attr) => {\n                switch(attr) {\n                    | Attr(name, _) => acc @ [name];\n                    | AttrInit(name, _, _) => acc @ [name];\n                }\n            };\n            // get types of attr\n            let get_types = (acc, attr) => {\n                switch(attr) {\n                    | Attr(_, typ) => acc @ [typ];\n                    | AttrInit(_, typ, _) => acc @ [typ];\n                }\n            };\n\n            // get the names and types of the attributes into lists\n            let names = List.fold_left(get_name, [], attrs);\n            let types = List.fold_left(get_types, [], attrs);\n\n            // create new list(name, location)\n            let make_new_attrs = (acc, name, loc) => {\n                acc @ [(name, loc)];\n            }\n            let new_attrs = List.fold_left2(make_new_attrs, [], names, li);\n\n            // make a new object of type t0 with default types\n            let v1 = switch(t0) {\n                | \"Bool\" => Bool(false);\n                | \"Int\" => Int(0);\n                | \"String\" => String(0, \"\");\n                | _ => Dynamic(t0, new_attrs, new_loc(sto));\n            };\n            let defaults = List.fold_left(get_default_vals, [], types)\n\n            // add in the new location-default value pairs to the store\n            let sto2 = List.fold_left2(fill_sto_entry, sto, li, defaults);\n\n            // add in the name-new location\n            let env2 = List.fold_left2(fill_env_entry, env, names, li); \n\n            // create assign expression for those attrs with initializers\n            // and filter out the ones that do not need to be initialized\n            let make_assigns = (acc, attr) => {\n                switch(attr){\n                    | Attr(_,_) => acc; // skip non init attr\n                    | AttrInit(name, typ, expr) => \n                        // potentially wrong types here\n                        // exp = (lineno, type, subpart)\n                        // subpart = Assign(ident, expr)\n                        acc @ [(line, typ, Assign((line, name), expr))];\n                }\n            };\n\n            // create a block of assignments to evaluated\n            let assigns = List.fold_left(make_assigns, [], attrs);\n            let block = (line, t0, Block(assigns)); // currently returns VOID\n            let(_, sto3) = eval_expr(v1, env2, sto2, block); // returns v2, sto3\n\n            // decrement activation counter\n            update(false, line);\n\n            // return the new object and new store from the assigns\n            (v1, sto3); \n        }\n        | Isvoid(expr) => {\n            let (v, sto2) = eval_expr(so, env, sto, expr);\n\n            switch(v) {\n                | Void => (Bool(true), sto2); // if void, true\n                | _ => (Bool(false), sto2); // if anything else, false\n            }\n        }\n        | Plus(x, y) => { // use functional programming to do the math\n            compute_arithmetic(x, y, (+), false)\n        }\n        | Minus(x, y) => {\n            compute_arithmetic(x, y, (-), false)\n        }\n        | Times(x, y) => {\n            compute_arithmetic(x, y, (*), false)\n        }\n        | Divide(x, y) => {\n            compute_arithmetic(x, y, (/), true);\n        }\n        | Lt(x, y) => {\n            // evaluate the expressions\n            let (v_x, sto2) = eval_expr(so, env, sto, x);\n            let (v_y, sto3) = eval_expr(so, env, sto2, y);\n\n            switch(v_x, v_y) {\n                | (Void, Void) => (Bool(false), sto3); // Void is always false\n                | (Bool(i), Bool(j)) => (Bool(i < j), sto3);\n                | (Int(i), Int(j)) => (Bool(i < j), sto3);\n                | (String(_, str_i), String(_, str_j)) => {\n                    // compare the strings\n                    if (String.compare(str_i, str_j) < 0) {\n                        (Bool(true), sto3);\n                    } else {\n                        (Bool(false), sto3);\n                    }\n                } \n                | (Dynamic(_, _, _), Dynamic(_, _, _)) => (Bool(false), sto3); // always returns false if different objects\n                | _ => {print_endline(\"557\"); exit(1)};\n            }\n        } \n        | Eq(x, y) =>  {\n            // evaluate the expressions\n            let (v_x, sto2) = eval_expr(so, env, sto, x);\n            let (v_y, sto3) = eval_expr(so, env, sto2, y);\n\n            switch(v_x, v_y) {\n                | (Void, Void) => (Bool(true), sto3); // two voids are always equal to each other \n                | (Bool(i), Bool(j)) => (Bool(i == j), sto3);\n                | (Int(i), Int(j)) => (Bool(i == j), sto3);\n                | (String(_, str_i), String(_, str_j)) => {\n                    if (String.compare(str_i, str_j) == 0) {\n                        (Bool(true), sto3);\n                    } else {\n                        (Bool(false), sto3);\n                    }\n                } \n                | (Dynamic(_, _, loc_i), Dynamic(_, _, loc_j)) => {\n                    if (loc_i == loc_j) {\n                        // check that all the locations are equal, if so then the objects are the same\n                        (Bool(true), sto3);\n                    } else {\n                        (Bool(false), sto3); // always returns false if different objects\n                    };\n                }; \n                | (_, Void) | (Void, _) => (Bool(false), sto3) // void is only equal to void\n                | _ => {print_endline(\"587\"); exit(1)};\n            }\n        }\n        | Le(x, y) =>  {\n            // evaluate the expressions\n            let (v_x, sto2) = eval_expr(so, env, sto, x);\n            let (v_y, sto3) = eval_expr(so, env, sto2, y);\n\n            switch(v_x, v_y) {\n                | (Void, Void) => (Bool(true), sto3); // two voids are always equal to each other \n                | (Bool(i), Bool(j)) => (Bool(i <= j), sto3);\n                | (Int(i), Int(j)) => (Bool(i <= j), sto3);\n                | (String(_, str_i), String(_, str_j)) => {\n                    if (String.compare(str_i, str_j) <= 0) {\n                        (Bool(true), sto3);\n                    }\n                    else {\n                        (Bool(false), sto3);\n                    }\n                } \n                | (Dynamic(_, _, loc_i), Dynamic(_, _, loc_j)) => {\n                    if (loc_i == loc_j) {\n                        // check that all the locations are equal, if so then the objects are the same\n                        (Bool(true), sto3);\n                    } else {\n                        (Bool(false), sto3); // always returns false if different objects\n                    };\n                    \n                    \n                };\n                | (_, Void) | (Void, _) => (Bool(false), sto3) // void is only equal to void\n                | _ => {print_endline(\"617\"); exit(1)};\n            }\n        } \n        | Not(expr) => {\n            // evaluate the expressions\n            let (v, sto2) = eval_expr(so, env, sto, expr);\n\n            // flip the bool\n            switch(v) {\n                | Bool(true) => (Bool(false), sto2); \n                | Bool(false) => (Bool(true), sto2);\n                | _ => {print_endline(\"626\"); exit(1)};\n            }\n        }\n        | Negate(expr) => { // again may need to check for number in bounds of 32 bits\n            // evaluate the expressions\n            let (v, sto2) = eval_expr(so, env, sto, expr);\n\n            // multiply by -1 to negate\n            switch(v) {\n                | Int(i) => (Int(-1*i), sto2);\n                | _ => {print_endline(\"634\"); exit(1)};\n            }\n        }\n        | Integer(num) => {\n            // evaluates to value Int and the same store\n            (Int(num), sto);\n        }\n        | String(str) => { \n            // get length of the string\n            let len = String.length(str);\n            // return string object (length, string) and store            \n            (String(len, str), sto);  \n        }\n        | True => {\n            // evaluates to Bool value true and the same store\n            (Bool(true), sto);\n        }\n        | False => {\n            // evaluates to Bool value false and the same store\n            (Bool(false), sto);\n        }\n        | Let(bindings, expr) => {\n            \n            // internal to evaluate\n            let eval_one_let = (binding, expr) => {\n                // get the name of the variable, its value, and the new store55\n                let (var, (v1, sto2)) = switch(binding) {\n                        // evaluate the init exp\n                        | BindInit(var, _, e) => {\n                            (var, eval_expr(so, env, sto, e))\n                        };\n\n                        // get the default value if there is not init exp\n                        | Bind(var, typ) => {\n                            let (_, type_info) = typ;\n                            \n                            // function returns a list of defaults so get the one value\n                            let v1 = switch(get_default_vals([], type_info)) {\n                                | [hd, ...[]] => hd;\n                                | _ => {print_endline(\"671\"); exit(1)};\n                            };\n\n                            (var, (v1, sto));\n                        };\n                    };\n\n                    // make a new location for the variable\n                    let l1 = new_loc(sto2); \n\n                    // put it in the store\n                    let sto3 = LocationMap.add(l1, v1, sto2);\n\n                    // put it in the env\n                    let(_, name) = var;\n                    let env2 = StringMap.add(name, l1, env);\n\n                    // evaluate the let exp with the new store and env\n                    let (vf, stof) = eval_expr(so, env2, sto3, expr);\n                    \n                    (vf, stof);\n            };\n            \n            // evaluate the bindings\n            switch(bindings) {\n                | [hd, ...[]] => {\n                    eval_one_let(hd, expr);\n                };\n                | [hd, ... tl] => {\n                    // evaluate the first, but make a new let to evalate with all the other bindings\n                    let inner_let = (line, typ_expr, Let(tl, expr));\n                    eval_one_let(hd, inner_let);\n                };\n                | _ => {print_endline(\"703\"); exit(1)};\n            };\n        };\n        | Case(expr, case_elements) => {\n            \n            // evaluate the case expression\n            let(v0, sto2) = eval_expr(so, env, sto, expr);\n\n            // get the type of v0\n            let x_typ = switch(getType(v0)) {\n                | \"Void\" => { // error if case exp is void\n                    print_endline(\"ERROR: \"++ string_of_int(line) ++ \": Exception: case on void\");\n                    exit(1);\n                };\n                | typ => typ;\t// otherwise return the type\n            }\n\n            // check if a branch matches x, then check parents, etc.\n            // filter to get any case elements that match the current x type\n            let rec same_as_x = (x_typ, elements, acc) => {\n                switch(elements) {\n                    | [hd,...tl] => {\n                        let (_, (_,typ), _) = hd; \n                        if (x_typ == typ) {\n                            same_as_x(x_typ, tl, acc @ [hd]);\n                        } else {\n                            acc;\n                        }\n                    }\n                    | [] => acc;\n                };\n            };\n\n            let rec get_branch = (x_typ, case_elements) => {\n                // See if this type matches any branches\n                // same as x will return an empty list if none of the elements had x_type or will return the one case that does match \n                switch(same_as_x(x_typ, case_elements, [])) {\n                    | [] => {\n                        // if at object, there is no more parents to check\n                        if (x_typ == \"Object\") {\n                            print_endline(\"ERROR: \" ++ string_of_int(line) ++ \": Exception: case without matching branch: \" ++ x_typ ++ \"(...)\");\n                            exit(1);\n                        } else { // otherwise check the next parent\n                            get_branch(List.assoc(x_typ, parent_map), case_elements)\n                        }   \n                    }\n                    | [hd] => hd; // got a match\n                    | _ => {\n                        print_endline(\"something is wrong\"); \n                        exit(1);\n                    }\n                };\n            };    \n\n            // get variable and the expression from the selected branch \n            let ((_, id_i), (_,_), expr_i) = get_branch(x_typ, case_elements);\n            \n            // put the results in the environment and the store\n            let l0 = new_loc(sto2);\n            let sto3 = LocationMap.add(l0, v0, sto);\n            let env2 = StringMap.add(id_i, l0, env);\n\n            // returns (v1, sto4)\n            eval_expr(so, env2, sto3, expr_i); \n        }\n        | Internal(str) => {\n            switch (str) {\n                | \"IO.in_int\" => {\n                    // read entire line first, catching error if nothing before end of line\n                    let inp = switch(read_line()) {\n                        | line => line;\n                        | exception(_) => \"0\";\n                    };\n\n                    // get only the part we want from the line\n                    let i = switch(Scanf.bscanf(Scanf.Scanning.from_string(inp), \" %d\", x => x)) {\n                        | exception(_) => 0;\n                        | i => i;\n                    };\n\n                    // ensure it is less than 32 bits\n                    if(i < -2147483648 || i > 2147483647) {\n                        (Int(0), sto)\n                    } else {\n                        (Int(i), sto);\n                    };\n                };\n                | \"IO.out_int\" => {\n                    // look for IO methods\n                    let(methods) = List.assoc(\"IO\", imp_map);\n\n                    // use the function name to get the method information\n                    let((formals, _, _)) = List.assoc(\"out_int\", methods);\n\n                    let arg = switch(formals) {\n                        | [hd, ...[]] => {\n                            let loc = StringMap.find(hd, env);\n                            LocationMap.find(loc, sto);\n                        };\n                        | _ => {print_endline(\"798\"); exit(1)};\n                    };\n\n                    // print out the number\n                    switch(arg) {\n                        | Int(num) => Printf.printf(\"%d\", num);\n                        | _ => {print_endline(\"803\"); exit(1)};\n                    };\n                    \n                    // self_type, store\n                    (so, sto);\n                };\n                | \"IO.in_string\" => {\n                    // read the string, reason will break if it contains a null char\n                    // marker is true if null character is found\n                    let marker= ref(false);\n                    let input = switch(input_line(stdin)) {\n                        | str => {\n                            // look at each char to identify any null character\n                            for(i in 0 to String.length(str)-1) {\n                                let ch : char = str.[i];\n                                if (Char.code(ch) == 00) {\n                                    marker := true;\n                                }\n                            }\n                            // return an empty string if null character is found\n                            if(marker^ == true) \"\" else str;\n                        };\n                        | exception(_) => \"\";\n                    };\n\n                    // return the string read in and the store\n                    (String(String.length(input), input), sto);\n                };\n                | \"IO.out_string\" => {\n                    // look for IO methods\n                    let(methods) = List.assoc(\"IO\", imp_map);\n\n                    // use the function name to get the method information\n                    let((formals, _, _)) = List.assoc(\"out_string\", methods);\n\n                    // get the string to output from the store\n                    let arg = switch(formals) {\n                        | [hd, ...[]] => {\n                            let loc = StringMap.find(hd, env);\n                            LocationMap.find(loc, sto);\n                        };\n                        | _ => {print_endline(\"842\"); exit(1)};\n                    };\n\n                    switch(arg) {\n                        | String(_, str) => {\n\n                            // look for escape characters\n                            let newline = Str.regexp(\"\\\\\\\\n\");\n                            let str = Str.global_replace(newline, \"\\n\", str);\n                            \n                            let tab = Str.regexp(\"\\\\\\\\t\");\n                            let str = Str.global_replace(tab, \"\\t\", str);\n                            \n                            // print it out\n                            print_string(str);\n                        }\n                        | _ => {print_endline(\"860\"); exit(1)};\n                    };\n                    \n                    // self_type, store\n                    (so, sto);\n                };\n                | \"Object.abort\" => {\n                    // flush and print\n                    print_endline(\"abort\");  \n                    exit(1);\n                }; \n                | \"Object.copy\" => {\n                    // Get the object's attributes\n                    let so_info = switch(so) {\n                        | Void => (\"Void\", [])\n                        | Bool(_) => (\"Bool\", [])\n                        | Int(_) => (\"Int\", [])\n                        | String(_, _) => (\"String\", []);\n                        | Dynamic(name, attr_tuple, _) => (name, attr_tuple);\n                    }\n                    \n                    // type, list(name, loc)\n                    let(name, attr_tuple) = so_info; \n\n                    // decompose\n                    let(attrs, la) = List.split(attr_tuple);  \n\n                    // Get copies of the attributes\n                    let copy_val = (acc: list(value), loc: location) => {\n                        acc @ [switch(LocationMap.find(loc, sto)) {\n                        | l => l;\n                        | exception(_) => print_endline(\"failed to find value (copy)\"); exit(1);\n                        }];\n                    }\n                    let vals = List.fold_left(copy_val, [], la)\n\n                    // Create a new store location for each attribute\n                    let locs = get_l(List.length(vals), sto, []);\n\n                    // Assign copy of attribute value to the location\n                    let sto2 = List.fold_left2(fill_sto_entry, sto, locs, vals);\n\n                    (Dynamic(name, List.combine(attrs, locs), new_loc(sto2)), sto2);\n                };\n                   \n                | \"Object.type_name\" => {\n                    let typ = getType(so);\n                    // get the type and return it as a string with the store\n                    (String(String.length(typ), typ), sto);\n                }\n                | \"String.concat\" => { // concat(s: string)\n                    \n                    // get a new string object wiht the concat'd string\n                    let concat = switch(so) {\n                        // concat uses string from the so\n                    | String(_, str) => {\n                        // look up the parameter s in the env and get its value\n                        let loc_s = StringMap.find(\"s\", env);\n                        let s_val = LocationMap.find(loc_s, sto);\n                        \n                        // combine the string from so and the s\n                        switch(s_val) {\n                            | (String(_, s)) => {\n                                \n                                let new_str = String.concat(\"\", [str, s]);\n                                String(String.length(new_str), new_str);\n                            }\n                            | _ => {print_endline(\"922\"); exit(1)};\n                        };\n                    }\n                    | _ => failwith(\"too many concat parameters\");\n                    };\n\n                    // new concat string value and store\n                    (concat, sto);\n                };\n                | \"String.length\" => {\n                    // get the length from the so\n                    switch(so) {\n                        | String(num, _) => (Int(num), sto);\n                        | _ => {print_endline(\"935\"); exit(1)};\n                    };\n                };\n                | \"String.substr\" => {  \n                    // get the index and length parameter values\n                    let loc_i = StringMap.find(\"i\", env);\n                    let i_val = LocationMap.find(loc_i, sto);\n\n                    let loc_l = StringMap.find(\"l\", env);\n                    let l_val = LocationMap.find(loc_l, sto);\n\n                    // get the substring\n                    let sub = switch(i_val, l_val) {\n                        // get the i and l\n                        | (Int(i), Int(l)) => {\n                            let (str_len, str) = switch(so) {\n                                | String(str_len, str) => (str_len, str);\n                                | _ => {print_endline(\"952\"); exit(1)};\n                            };\n\n                            // out of bounds\n                            if (i + l >= str_len) {\n                                print_endline(\"ERROR: 0: Exception: String.substr out of range\");\n                                exit(1);\n                            };\n                            \n                            let substr = String.sub(str, i, l);\n                            String(String.length(substr), substr);\n                        }\n                        | _ => {print_endline(\"964\"); exit(1)};\n                    };\n                    (sub, sto);\n                };\n                | _ => {print_endline(\"968\"); exit(1)};\n            };\n        }\n    }\n};\n\n// create an empty store and environment and a self object\nlet sto = LocationMap.empty;\nlet env = StringMap.empty;\nlet so = Void;\n\nlet init_exp = (0, \"object\", DynamicDispatch(\n    // target object expression - new Main = New(ident)\n    (0, \"Main\", New((0, \"Main\"))),\n    // method name - ident\n    (0, \"main\"),\n    //list of args\n    [])\n);\n\n// run the program\neval_expr(so, env, sto, init_exp);\n"}}}
Found a `dune` file at /Users/kim/Desktop/Notes/Programming_Languages/P5
]] Making a new jbuilder package at /Users/kim/Desktop/Notes/Programming_Languages/P5
=== Project root: /Users/kim/Desktop/Notes/Programming_Languages/P5
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
New dune process
[MerlinFile]: Error: Insufficient build files found for module Interpreter - src: /Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re, srci: (), cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Ast1 - src: /Users/kim/Desktop/Notes/Programming_Languages/P5/ast1.re, srci: (), cmi: (), cmt: (), cmti: ()
>> Build system running: opam exec -- dune build @install --root .
>>> stdout

>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/kim/Desktop/Notes/Programming_Languages/P5/bsconfig.json", "diagnostics": []}}
 > /Users/kim/.opam/4.08.1/lib/ocaml/unixLabels.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/stack.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/str.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/stdlib.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/ephemeron.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/stream.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/set.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/fun.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/format.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/printf.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/fun.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/char.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/float.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/moreLabels.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/stdlib.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/weak.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/raw_spacetime_lib.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/callback.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/callback.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/buffer.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/uchar.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/uchar.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/lexing.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/arrayLabels.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/stack.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/weak.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/option.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/stdLabels.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/printexc.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/obj.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/stringLabels.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/arg.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/int.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/genlex.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/oo.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/list.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/scanf.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/string.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/unix.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/spacetime.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalLazy.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/hashtbl.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/topdirs.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/char.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/listLabels.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalFormat.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/bool.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/int32.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/float.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalOO.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/moreLabels.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/sys.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/stdLabels.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/seq.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/lazy.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/marshal.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/int.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/complex.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/parsing.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/buffer.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/filename.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/listLabels.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/lazy.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/queue.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalMod.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/option.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/parsing.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/arg.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/bytes.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/string.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/oo.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/printexc.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/bytesLabels.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/gc.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalOO.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/sys.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/queue.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/unit.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalLazy.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/bool.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/marshal.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/result.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/bytes.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/obj.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/genlex.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/filename.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/arrayLabels.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/stream.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/list.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/int32.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/random.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/scanf.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/bigarray.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/random.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/lexing.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/ephemeron.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/digest.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalMod.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/pervasives.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/bigarray.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalFormat.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/seq.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/map.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/dynlink.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/result.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/gc.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/array.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/format.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/printf.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/int64.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalFormatBasics.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/stringLabels.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/spacetime.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/nativeint.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/int64.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/bytesLabels.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/unit.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/digest.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/complex.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/camlinternalFormatBasics.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/std_exit.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/nativeint.ml
 > /Users/kim/.opam/4.08.1/lib/ocaml/array.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/map.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/hashtbl.mli
 > /Users/kim/.opam/4.08.1/lib/ocaml/set.mli
Reloading because you created a new file: /Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re
Running diagnostics for file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re
➡️ running compiler /Users/kim/.opam/4.08.1/bin/ocamlopt.opt -c -I '/Users/kim/.opam/4.08.1/lib/ocaml' -I '_build/default/.interpreter.eobjs/byte' -I '/Users/kim/.opam/4.08.1/lib/ocaml' -bin-annot -open Dune__exe -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/kim/Desktop/Notes/Programming_Languages/P5/_build/.lsp/Interpreter.ast with pwd /Users/kim/Desktop/Notes/Programming_Languages/P5
Ident!! Map.Make
Ident!! OrderedLocation
Ident!! Map.Make
Ident!! String
<< Replacing lastDefinitions for file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1, "jsonrpc": "2.0", "result": [{"name": "activations", "kind": 13, "location": {"range": {"start": {"line": 7, "character": 0}, "end": {"line": 7, "character": 24}}, "uri": "file://"}}, {"name": "update", "kind": 12, "location": {"range": {"start": {"line": 10, "character": 0}, "end": {"line": 26, "character": 1}}, "uri": "file://"}}, {"name": "ast_file", "kind": 13, "location": {"range": {"start": {"line": 35, "character": 0}, "end": {"line": 35, "character": 35}}, "uri": "file://"}}, {"name": "location", "kind": 26, "location": {"range": {"start": {"line": 41, "character": 0}, "end": {"line": 41, "character": 19}}, "uri": "file://"}}, {"name": "value", "kind": 10, "location": {"range": {"start": {"line": 44, "character": 0}, "end": {"line": 49, "character": 57}}, "uri": "file://"}}, {"name": "getType", "kind": 12, "location": {"range": {"start": {"line": 52, "character": 0}, "end": {"line": 60, "character": 1}}, "uri": "file://"}}, {"name": "OrderedLocation", "kind": 2, "location": {"range": {"start": {"line": 63, "character": 0}, "end": {"line": 66, "character": 1}}, "uri": "file://"}}, {"name": "t", "kind": 26, "location": {"range": {"start": {"line": 64, "character": 4}, "end": {"line": 64, "character": 21}}, "uri": "file://"}}, {"name": "compare", "kind": 12, "location": {"range": {"start": {"line": 65, "character": 4}, "end": {"line": 65, "character": 25}}, "uri": "file://"}}, {"name": "LocationMap", "kind": 2, "location": {"range": {"start": {"line": 67, "character": 0}, "end": {"line": 67, "character": 46}}, "uri": "file://"}}, {"name": "of_seq", "kind": 12, "location": {"range": {"start": {"line": 323, "character": 4}, "end": {"line": 323, "character": 41}}, "uri": "file://map.mli"}}, {"name": "add_seq", "kind": 12, "location": {"range": {"start": {"line": 319, "character": 4}, "end": {"line": 319, "character": 50}}, "uri": "file://map.mli"}}, {"name": "to_seq_from", "kind": 12, "location": {"range": {"start": {"line": 314, "character": 4}, "end": {"line": 314, "character": 53}}, "uri": "file://map.mli"}}, {"name": "to_seq", "kind": 12, "location": {"range": {"start": {"line": 310, "character": 4}, "end": {"line": 310, "character": 41}}, "uri": "file://map.mli"}}, {"name": "mapi", "kind": 12, "location": {"range": {"start": {"line": 304, "character": 4}, "end": {"line": 304, "character": 47}}, "uri": "file://map.mli"}}, {"name": "map", "kind": 12, "location": {"range": {"start": {"line": 297, "character": 4}, "end": {"line": 297, "character": 39}}, "uri": "file://map.mli"}}, {"name": "find_last_opt", "kind": 12, "location": {"range": {"start": {"line": 290, "character": 4}, "end": {"line": 290, "character": 65}}, "uri": "file://map.mli"}}, {"name": "find_last", "kind": 12, "location": {"range": {"start": {"line": 283, "character": 4}, "end": {"line": 283, "character": 52}}, "uri": "file://map.mli"}}, {"name": "find_first_opt", "kind": 12, "location": {"range": {"start": {"line": 276, "character": 4}, "end": {"line": 276, "character": 66}}, "uri": "file://map.mli"}}, {"name": "find_first", "kind": 12, "location": {"range": {"start": {"line": 263, "character": 4}, "end": {"line": 263, "character": 53}}, "uri": "file://map.mli"}}, {"name": "find_opt", "kind": 12, "location": {"range": {"start": {"line": 257, "character": 4}, "end": {"line": 257, "character": 42}}, "uri": "file://map.mli"}}, {"name": "find", "kind": 12, "location": {"range": {"start": {"line": 253, "character": 4}, "end": {"line": 253, "character": 31}}, "uri": "file://map.mli"}}, {"name": "split", "kind": 12, "location": {"range": {"start": {"line": 242, "character": 4}, "end": {"line": 242, "character": 53}}, "uri": "file://map.mli"}}, {"name": "choose_opt", "kind": 12, "location": {"range": {"start": {"line": 235, "character": 4}, "end": {"line": 235, "character": 45}}, "uri": "file://map.mli"}}, {"name": "choose", "kind": 12, "location": {"range": {"start": {"line": 228, "character": 4}, "end": {"line": 228, "character": 34}}, "uri": "file://map.mli"}}, {"name": "max_binding_opt", "kind": 12, "location": {"range": {"start": {"line": 222, "character": 4}, "end": {"line": 222, "character": 50}}, "uri": "file://map.mli"}}, {"name": "max_binding", "kind": 12, "location": {"range": {"start": {"line": 216, "character": 4}, "end": {"line": 216, "character": 39}}, "uri": "file://map.mli"}}, {"name": "min_binding_opt", "kind": 12, "location": {"range": {"start": {"line": 209, "character": 4}, "end": {"line": 209, "character": 50}}, "uri": "file://map.mli"}}, {"name": "min_binding", "kind": 12, "location": {"range": {"start": {"line": 202, "character": 4}, "end": {"line": 202, "character": 39}}, "uri": "file://map.mli"}}, {"name": "bindings", "kind": 12, "location": {"range": {"start": {"line": 194, "character": 4}, "end": {"line": 194, "character": 41}}, "uri": "file://map.mli"}}, {"name": "cardinal", "kind": 12, "location": {"range": {"start": {"line": 189, "character": 4}, "end": {"line": 189, "character": 29}}, "uri": "file://map.mli"}}, {"name": "partition", "kind": 12, "location": {"range": {"start": {"line": 181, "character": 4}, "end": {"line": 181, "character": 61}}, "uri": "file://map.mli"}}, {"name": "filter", "kind": 12, "location": {"range": {"start": {"line": 172, "character": 4}, "end": {"line": 172, "character": 51}}, "uri": "file://map.mli"}}, {"name": "exists", "kind": 12, "location": {"range": {"start": {"line": 166, "character": 4}, "end": {"line": 166, "character": 51}}, "uri": "file://map.mli"}}, {"name": "for_all", "kind": 12, "location": {"range": {"start": {"line": 160, "character": 4}, "end": {"line": 160, "character": 52}}, "uri": "file://map.mli"}}, {"name": "fold", "kind": 12, "location": {"range": {"start": {"line": 155, "character": 4}, "end": {"line": 155, "character": 57}}, "uri": "file://map.mli"}}, {"name": "iter", "kind": 12, "location": {"range": {"start": {"line": 149, "character": 4}, "end": {"line": 149, "character": 49}}, "uri": "file://map.mli"}}, {"name": "equal", "kind": 12, "location": {"range": {"start": {"line": 143, "character": 4}, "end": {"line": 143, "character": 57}}, "uri": "file://map.mli"}}, {"name": "compare", "kind": 12, "location": {"range": {"start": {"line": 139, "character": 4}, "end": {"line": 139, "character": 57}}, "uri": "file://map.mli"}}, {"name": "union", "kind": 12, "location": {"range": {"start": {"line": 125, "character": 4}, "end": {"line": 125, "character": 69}}, "uri": "file://map.mli"}}, {"name": "merge", "kind": 12, "location": {"range": {"start": {"line": 114, "character": 4}, "end": {"line": 115, "character": 77}}, "uri": "file://map.mli"}}, {"name": "remove", "kind": 12, "location": {"range": {"start": {"line": 107, "character": 4}, "end": {"line": 107, "character": 35}}, "uri": "file://map.mli"}}, {"name": "singleton", "kind": 12, "location": {"range": {"start": {"line": 101, "character": 4}, "end": {"line": 101, "character": 36}}, "uri": "file://map.mli"}}, {"name": "update", "kind": 12, "location": {"range": {"start": {"line": 88, "character": 4}, "end": {"line": 88, "character": 63}}, "uri": "file://map.mli"}}, {"name": "add", "kind": 12, "location": {"range": {"start": {"line": 79, "character": 4}, "end": {"line": 79, "character": 38}}, "uri": "file://map.mli"}}, {"name": "mem", "kind": 12, "location": {"range": {"start": {"line": 75, "character": 4}, "end": {"line": 75, "character": 32}}, "uri": "file://map.mli"}}, {"name": "is_empty", "kind": 12, "location": {"range": {"start": {"line": 72, "character": 4}, "end": {"line": 72, "character": 30}}, "uri": "file://map.mli"}}, {"name": "empty", "kind": 13, "location": {"range": {"start": {"line": 69, "character": 4}, "end": {"line": 69, "character": 19}}, "uri": "file://map.mli"}}, {"name": "t", "kind": 26, "location": {"range": {"start": {"line": 66, "character": 4}, "end": {"line": 66, "character": 16}}, "uri": "file://map.mli"}}, {"name": "key", "kind": 26, "location": {"range": {"start": {"line": 329, "character": 41}, "end": {"line": 329, "character": 57}}, "uri": "file://map.mli"}}, {"name": "StringMap", "kind": 2, "location": {"range": {"start": {"line": 70, "character": 0}, "end": {"line": 70, "character": 35}}, "uri": "file://"}}, {"name": "of_seq", "kind": 12, "location": {"range": {"start": {"line": 323, "character": 4}, "end": {"line": 323, "character": 41}}, "uri": "file://map.mli"}}, {"name": "add_seq", "kind": 12, "location": {"range": {"start": {"line": 319, "character": 4}, "end": {"line": 319, "character": 50}}, "uri": "file://map.mli"}}, {"name": "to_seq_from", "kind": 12, "location": {"range": {"start": {"line": 314, "character": 4}, "end": {"line": 314, "character": 53}}, "uri": "file://map.mli"}}, {"name": "to_seq", "kind": 12, "location": {"range": {"start": {"line": 310, "character": 4}, "end": {"line": 310, "character": 41}}, "uri": "file://map.mli"}}, {"name": "mapi", "kind": 12, "location": {"range": {"start": {"line": 304, "character": 4}, "end": {"line": 304, "character": 47}}, "uri": "file://map.mli"}}, {"name": "map", "kind": 12, "location": {"range": {"start": {"line": 297, "character": 4}, "end": {"line": 297, "character": 39}}, "uri": "file://map.mli"}}, {"name": "find_last_opt", "kind": 12, "location": {"range": {"start": {"line": 290, "character": 4}, "end": {"line": 290, "character": 65}}, "uri": "file://map.mli"}}, {"name": "find_last", "kind": 12, "location": {"range": {"start": {"line": 283, "character": 4}, "end": {"line": 283, "character": 52}}, "uri": "file://map.mli"}}, {"name": "find_first_opt", "kind": 12, "location": {"range": {"start": {"line": 276, "character": 4}, "end": {"line": 276, "character": 66}}, "uri": "file://map.mli"}}, {"name": "find_first", "kind": 12, "location": {"range": {"start": {"line": 263, "character": 4}, "end": {"line": 263, "character": 53}}, "uri": "file://map.mli"}}, {"name": "find_opt", "kind": 12, "location": {"range": {"start": {"line": 257, "character": 4}, "end": {"line": 257, "character": 42}}, "uri": "file://map.mli"}}, {"name": "find", "kind": 12, "location": {"range": {"start": {"line": 253, "character": 4}, "end": {"line": 253, "character": 31}}, "uri": "file://map.mli"}}, {"name": "split", "kind": 12, "location": {"range": {"start": {"line": 242, "character": 4}, "end": {"line": 242, "character": 53}}, "uri": "file://map.mli"}}, {"name": "choose_opt", "kind": 12, "location": {"range": {"start": {"line": 235, "character": 4}, "end": {"line": 235, "character": 45}}, "uri": "file://map.mli"}}, {"name": "choose", "kind": 12, "location": {"range": {"start": {"line": 228, "character": 4}, "end": {"line": 228, "character": 34}}, "uri": "file://map.mli"}}, {"name": "max_binding_opt", "kind": 12, "location": {"range": {"start": {"line": 222, "character": 4}, "end": {"line": 222, "character": 50}}, "uri": "file://map.mli"}}, {"name": "max_binding", "kind": 12, "location": {"range": {"start": {"line": 216, "character": 4}, "end": {"line": 216, "character": 39}}, "uri": "file://map.mli"}}, {"name": "min_binding_opt", "kind": 12, "location": {"range": {"start": {"line": 209, "character": 4}, "end": {"line": 209, "character": 50}}, "uri": "file://map.mli"}}, {"name": "min_binding", "kind": 12, "location": {"range": {"start": {"line": 202, "character": 4}, "end": {"line": 202, "character": 39}}, "uri": "file://map.mli"}}, {"name": "bindings", "kind": 12, "location": {"range": {"start": {"line": 194, "character": 4}, "end": {"line": 194, "character": 41}}, "uri": "file://map.mli"}}, {"name": "cardinal", "kind": 12, "location": {"range": {"start": {"line": 189, "character": 4}, "end": {"line": 189, "character": 29}}, "uri": "file://map.mli"}}, {"name": "partition", "kind": 12, "location": {"range": {"start": {"line": 181, "character": 4}, "end": {"line": 181, "character": 61}}, "uri": "file://map.mli"}}, {"name": "filter", "kind": 12, "location": {"range": {"start": {"line": 172, "character": 4}, "end": {"line": 172, "character": 51}}, "uri": "file://map.mli"}}, {"name": "exists", "kind": 12, "location": {"range": {"start": {"line": 166, "character": 4}, "end": {"line": 166, "character": 51}}, "uri": "file://map.mli"}}, {"name": "for_all", "kind": 12, "location": {"range": {"start": {"line": 160, "character": 4}, "end": {"line": 160, "character": 52}}, "uri": "file://map.mli"}}, {"name": "fold", "kind": 12, "location": {"range": {"start": {"line": 155, "character": 4}, "end": {"line": 155, "character": 57}}, "uri": "file://map.mli"}}, {"name": "iter", "kind": 12, "location": {"range": {"start": {"line": 149, "character": 4}, "end": {"line": 149, "character": 49}}, "uri": "file://map.mli"}}, {"name": "equal", "kind": 12, "location": {"range": {"start": {"line": 143, "character": 4}, "end": {"line": 143, "character": 57}}, "uri": "file://map.mli"}}, {"name": "compare", "kind": 12, "location": {"range": {"start": {"line": 139, "character": 4}, "end": {"line": 139, "character": 57}}, "uri": "file://map.mli"}}, {"name": "union", "kind": 12, "location": {"range": {"start": {"line": 125, "character": 4}, "end": {"line": 125, "character": 69}}, "uri": "file://map.mli"}}, {"name": "merge", "kind": 12, "location": {"range": {"start": {"line": 114, "character": 4}, "end": {"line": 115, "character": 77}}, "uri": "file://map.mli"}}, {"name": "remove", "kind": 12, "location": {"range": {"start": {"line": 107, "character": 4}, "end": {"line": 107, "character": 35}}, "uri": "file://map.mli"}}, {"name": "singleton", "kind": 12, "location": {"range": {"start": {"line": 101, "character": 4}, "end": {"line": 101, "character": 36}}, "uri": "file://map.mli"}}, {"name": "update", "kind": 12, "location": {"range": {"start": {"line": 88, "character": 4}, "end": {"line": 88, "character": 63}}, "uri": "file://map.mli"}}, {"name": "add", "kind": 12, "location": {"range": {"start": {"line": 79, "character": 4}, "end": {"line": 79, "character": 38}}, "uri": "file://map.mli"}}, {"name": "mem", "kind": 12, "location": {"range": {"start": {"line": 75, "character": 4}, "end": {"line": 75, "character": 32}}, "uri": "file://map.mli"}}, {"name": "is_empty", "kind": 12, "location": {"range": {"start": {"line": 72, "character": 4}, "end": {"line": 72, "character": 30}}, "uri": "file://map.mli"}}, {"name": "empty", "kind": 13, "location": {"range": {"start": {"line": 69, "character": 4}, "end": {"line": 69, "character": 19}}, "uri": "file://map.mli"}}, {"name": "t", "kind": 26, "location": {"range": {"start": {"line": 66, "character": 4}, "end": {"line": 66, "character": 16}}, "uri": "file://map.mli"}}, {"name": "key", "kind": 26, "location": {"range": {"start": {"line": 329, "character": 41}, "end": {"line": 329, "character": 57}}, "uri": "file://map.mli"}}, {"name": "new_loc", "kind": 12, "location": {"range": {"start": {"line": 73, "character": 0}, "end": {"line": 85, "character": 1}}, "uri": "file://"}}, {"name": "fill_sto_entry", "kind": 12, "location": {"range": {"start": {"line": 88, "character": 0}, "end": {"line": 90, "character": 1}}, "uri": "file://"}}, {"name": "fill_env_entry", "kind": 12, "location": {"range": {"start": {"line": 93, "character": 0}, "end": {"line": 95, "character": 1}}, "uri": "file://"}}, {"name": "eval_expr", "kind": 12, "location": {"range": {"start": {"line": 98, "character": 0}, "end": {"line": 994, "character": 1}}, "uri": "file://"}}, {"name": "sto", "kind": 13, "location": {"range": {"start": {"line": 997, "character": 0}, "end": {"line": 997, "character": 27}}, "uri": "file://"}}, {"name": "env", "kind": 13, "location": {"range": {"start": {"line": 998, "character": 0}, "end": {"line": 998, "character": 25}}, "uri": "file://"}}, {"name": "so", "kind": 13, "location": {"range": {"start": {"line": 999, "character": 0}, "end": {"line": 999, "character": 13}}, "uri": "file://"}}, {"name": "init_exp", "kind": 18, "location": {"range": {"start": {"line": 1001, "character": 0}, "end": {"line": 1008, "character": 1}}, "uri": "file://"}}]}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re"},"range":{"start":{"line":6,"character":31},"end":{"line":6,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 3, "jsonrpc": "2.0", "result": [{"name": "activations", "kind": 13, "location": {"range": {"start": {"line": 7, "character": 0}, "end": {"line": 7, "character": 24}}, "uri": "file://"}}, {"name": "update", "kind": 12, "location": {"range": {"start": {"line": 10, "character": 0}, "end": {"line": 26, "character": 1}}, "uri": "file://"}}, {"name": "ast_file", "kind": 13, "location": {"range": {"start": {"line": 35, "character": 0}, "end": {"line": 35, "character": 35}}, "uri": "file://"}}, {"name": "location", "kind": 26, "location": {"range": {"start": {"line": 41, "character": 0}, "end": {"line": 41, "character": 19}}, "uri": "file://"}}, {"name": "value", "kind": 10, "location": {"range": {"start": {"line": 44, "character": 0}, "end": {"line": 49, "character": 57}}, "uri": "file://"}}, {"name": "getType", "kind": 12, "location": {"range": {"start": {"line": 52, "character": 0}, "end": {"line": 60, "character": 1}}, "uri": "file://"}}, {"name": "OrderedLocation", "kind": 2, "location": {"range": {"start": {"line": 63, "character": 0}, "end": {"line": 66, "character": 1}}, "uri": "file://"}}, {"name": "t", "kind": 26, "location": {"range": {"start": {"line": 64, "character": 4}, "end": {"line": 64, "character": 21}}, "uri": "file://"}}, {"name": "compare", "kind": 12, "location": {"range": {"start": {"line": 65, "character": 4}, "end": {"line": 65, "character": 25}}, "uri": "file://"}}, {"name": "LocationMap", "kind": 2, "location": {"range": {"start": {"line": 67, "character": 0}, "end": {"line": 67, "character": 46}}, "uri": "file://"}}, {"name": "of_seq", "kind": 12, "location": {"range": {"start": {"line": 323, "character": 4}, "end": {"line": 323, "character": 41}}, "uri": "file://map.mli"}}, {"name": "add_seq", "kind": 12, "location": {"range": {"start": {"line": 319, "character": 4}, "end": {"line": 319, "character": 50}}, "uri": "file://map.mli"}}, {"name": "to_seq_from", "kind": 12, "location": {"range": {"start": {"line": 314, "character": 4}, "end": {"line": 314, "character": 53}}, "uri": "file://map.mli"}}, {"name": "to_seq", "kind": 12, "location": {"range": {"start": {"line": 310, "character": 4}, "end": {"line": 310, "character": 41}}, "uri": "file://map.mli"}}, {"name": "mapi", "kind": 12, "location": {"range": {"start": {"line": 304, "character": 4}, "end": {"line": 304, "character": 47}}, "uri": "file://map.mli"}}, {"name": "map", "kind": 12, "location": {"range": {"start": {"line": 297, "character": 4}, "end": {"line": 297, "character": 39}}, "uri": "file://map.mli"}}, {"name": "find_last_opt", "kind": 12, "location": {"range": {"start": {"line": 290, "character": 4}, "end": {"line": 290, "character": 65}}, "uri": "file://map.mli"}}, {"name": "find_last", "kind": 12, "location": {"range": {"start": {"line": 283, "character": 4}, "end": {"line": 283, "character": 52}}, "uri": "file://map.mli"}}, {"name": "find_first_opt", "kind": 12, "location": {"range": {"start": {"line": 276, "character": 4}, "end": {"line": 276, "character": 66}}, "uri": "file://map.mli"}}, {"name": "find_first", "kind": 12, "location": {"range": {"start": {"line": 263, "character": 4}, "end": {"line": 263, "character": 53}}, "uri": "file://map.mli"}}, {"name": "find_opt", "kind": 12, "location": {"range": {"start": {"line": 257, "character": 4}, "end": {"line": 257, "character": 42}}, "uri": "file://map.mli"}}, {"name": "find", "kind": 12, "location": {"range": {"start": {"line": 253, "character": 4}, "end": {"line": 253, "character": 31}}, "uri": "file://map.mli"}}, {"name": "split", "kind": 12, "location": {"range": {"start": {"line": 242, "character": 4}, "end": {"line": 242, "character": 53}}, "uri": "file://map.mli"}}, {"name": "choose_opt", "kind": 12, "location": {"range": {"start": {"line": 235, "character": 4}, "end": {"line": 235, "character": 45}}, "uri": "file://map.mli"}}, {"name": "choose", "kind": 12, "location": {"range": {"start": {"line": 228, "character": 4}, "end": {"line": 228, "character": 34}}, "uri": "file://map.mli"}}, {"name": "max_binding_opt", "kind": 12, "location": {"range": {"start": {"line": 222, "character": 4}, "end": {"line": 222, "character": 50}}, "uri": "file://map.mli"}}, {"name": "max_binding", "kind": 12, "location": {"range": {"start": {"line": 216, "character": 4}, "end": {"line": 216, "character": 39}}, "uri": "file://map.mli"}}, {"name": "min_binding_opt", "kind": 12, "location": {"range": {"start": {"line": 209, "character": 4}, "end": {"line": 209, "character": 50}}, "uri": "file://map.mli"}}, {"name": "min_binding", "kind": 12, "location": {"range": {"start": {"line": 202, "character": 4}, "end": {"line": 202, "character": 39}}, "uri": "file://map.mli"}}, {"name": "bindings", "kind": 12, "location": {"range": {"start": {"line": 194, "character": 4}, "end": {"line": 194, "character": 41}}, "uri": "file://map.mli"}}, {"name": "cardinal", "kind": 12, "location": {"range": {"start": {"line": 189, "character": 4}, "end": {"line": 189, "character": 29}}, "uri": "file://map.mli"}}, {"name": "partition", "kind": 12, "location": {"range": {"start": {"line": 181, "character": 4}, "end": {"line": 181, "character": 61}}, "uri": "file://map.mli"}}, {"name": "filter", "kind": 12, "location": {"range": {"start": {"line": 172, "character": 4}, "end": {"line": 172, "character": 51}}, "uri": "file://map.mli"}}, {"name": "exists", "kind": 12, "location": {"range": {"start": {"line": 166, "character": 4}, "end": {"line": 166, "character": 51}}, "uri": "file://map.mli"}}, {"name": "for_all", "kind": 12, "location": {"range": {"start": {"line": 160, "character": 4}, "end": {"line": 160, "character": 52}}, "uri": "file://map.mli"}}, {"name": "fold", "kind": 12, "location": {"range": {"start": {"line": 155, "character": 4}, "end": {"line": 155, "character": 57}}, "uri": "file://map.mli"}}, {"name": "iter", "kind": 12, "location": {"range": {"start": {"line": 149, "character": 4}, "end": {"line": 149, "character": 49}}, "uri": "file://map.mli"}}, {"name": "equal", "kind": 12, "location": {"range": {"start": {"line": 143, "character": 4}, "end": {"line": 143, "character": 57}}, "uri": "file://map.mli"}}, {"name": "compare", "kind": 12, "location": {"range": {"start": {"line": 139, "character": 4}, "end": {"line": 139, "character": 57}}, "uri": "file://map.mli"}}, {"name": "union", "kind": 12, "location": {"range": {"start": {"line": 125, "character": 4}, "end": {"line": 125, "character": 69}}, "uri": "file://map.mli"}}, {"name": "merge", "kind": 12, "location": {"range": {"start": {"line": 114, "character": 4}, "end": {"line": 115, "character": 77}}, "uri": "file://map.mli"}}, {"name": "remove", "kind": 12, "location": {"range": {"start": {"line": 107, "character": 4}, "end": {"line": 107, "character": 35}}, "uri": "file://map.mli"}}, {"name": "singleton", "kind": 12, "location": {"range": {"start": {"line": 101, "character": 4}, "end": {"line": 101, "character": 36}}, "uri": "file://map.mli"}}, {"name": "update", "kind": 12, "location": {"range": {"start": {"line": 88, "character": 4}, "end": {"line": 88, "character": 63}}, "uri": "file://map.mli"}}, {"name": "add", "kind": 12, "location": {"range": {"start": {"line": 79, "character": 4}, "end": {"line": 79, "character": 38}}, "uri": "file://map.mli"}}, {"name": "mem", "kind": 12, "location": {"range": {"start": {"line": 75, "character": 4}, "end": {"line": 75, "character": 32}}, "uri": "file://map.mli"}}, {"name": "is_empty", "kind": 12, "location": {"range": {"start": {"line": 72, "character": 4}, "end": {"line": 72, "character": 30}}, "uri": "file://map.mli"}}, {"name": "empty", "kind": 13, "location": {"range": {"start": {"line": 69, "character": 4}, "end": {"line": 69, "character": 19}}, "uri": "file://map.mli"}}, {"name": "t", "kind": 26, "location": {"range": {"start": {"line": 66, "character": 4}, "end": {"line": 66, "character": 16}}, "uri": "file://map.mli"}}, {"name": "key", "kind": 26, "location": {"range": {"start": {"line": 329, "character": 41}, "end": {"line": 329, "character": 57}}, "uri": "file://map.mli"}}, {"name": "StringMap", "kind": 2, "location": {"range": {"start": {"line": 70, "character": 0}, "end": {"line": 70, "character": 35}}, "uri": "file://"}}, {"name": "of_seq", "kind": 12, "location": {"range": {"start": {"line": 323, "character": 4}, "end": {"line": 323, "character": 41}}, "uri": "file://map.mli"}}, {"name": "add_seq", "kind": 12, "location": {"range": {"start": {"line": 319, "character": 4}, "end": {"line": 319, "character": 50}}, "uri": "file://map.mli"}}, {"name": "to_seq_from", "kind": 12, "location": {"range": {"start": {"line": 314, "character": 4}, "end": {"line": 314, "character": 53}}, "uri": "file://map.mli"}}, {"name": "to_seq", "kind": 12, "location": {"range": {"start": {"line": 310, "character": 4}, "end": {"line": 310, "character": 41}}, "uri": "file://map.mli"}}, {"name": "mapi", "kind": 12, "location": {"range": {"start": {"line": 304, "character": 4}, "end": {"line": 304, "character": 47}}, "uri": "file://map.mli"}}, {"name": "map", "kind": 12, "location": {"range": {"start": {"line": 297, "character": 4}, "end": {"line": 297, "character": 39}}, "uri": "file://map.mli"}}, {"name": "find_last_opt", "kind": 12, "location": {"range": {"start": {"line": 290, "character": 4}, "end": {"line": 290, "character": 65}}, "uri": "file://map.mli"}}, {"name": "find_last", "kind": 12, "location": {"range": {"start": {"line": 283, "character": 4}, "end": {"line": 283, "character": 52}}, "uri": "file://map.mli"}}, {"name": "find_first_opt", "kind": 12, "location": {"range": {"start": {"line": 276, "character": 4}, "end": {"line": 276, "character": 66}}, "uri": "file://map.mli"}}, {"name": "find_first", "kind": 12, "location": {"range": {"start": {"line": 263, "character": 4}, "end": {"line": 263, "character": 53}}, "uri": "file://map.mli"}}, {"name": "find_opt", "kind": 12, "location": {"range": {"start": {"line": 257, "character": 4}, "end": {"line": 257, "character": 42}}, "uri": "file://map.mli"}}, {"name": "find", "kind": 12, "location": {"range": {"start": {"line": 253, "character": 4}, "end": {"line": 253, "character": 31}}, "uri": "file://map.mli"}}, {"name": "split", "kind": 12, "location": {"range": {"start": {"line": 242, "character": 4}, "end": {"line": 242, "character": 53}}, "uri": "file://map.mli"}}, {"name": "choose_opt", "kind": 12, "location": {"range": {"start": {"line": 235, "character": 4}, "end": {"line": 235, "character": 45}}, "uri": "file://map.mli"}}, {"name": "choose", "kind": 12, "location": {"range": {"start": {"line": 228, "character": 4}, "end": {"line": 228, "character": 34}}, "uri": "file://map.mli"}}, {"name": "max_binding_opt", "kind": 12, "location": {"range": {"start": {"line": 222, "character": 4}, "end": {"line": 222, "character": 50}}, "uri": "file://map.mli"}}, {"name": "max_binding", "kind": 12, "location": {"range": {"start": {"line": 216, "character": 4}, "end": {"line": 216, "character": 39}}, "uri": "file://map.mli"}}, {"name": "min_binding_opt", "kind": 12, "location": {"range": {"start": {"line": 209, "character": 4}, "end": {"line": 209, "character": 50}}, "uri": "file://map.mli"}}, {"name": "min_binding", "kind": 12, "location": {"range": {"start": {"line": 202, "character": 4}, "end": {"line": 202, "character": 39}}, "uri": "file://map.mli"}}, {"name": "bindings", "kind": 12, "location": {"range": {"start": {"line": 194, "character": 4}, "end": {"line": 194, "character": 41}}, "uri": "file://map.mli"}}, {"name": "cardinal", "kind": 12, "location": {"range": {"start": {"line": 189, "character": 4}, "end": {"line": 189, "character": 29}}, "uri": "file://map.mli"}}, {"name": "partition", "kind": 12, "location": {"range": {"start": {"line": 181, "character": 4}, "end": {"line": 181, "character": 61}}, "uri": "file://map.mli"}}, {"name": "filter", "kind": 12, "location": {"range": {"start": {"line": 172, "character": 4}, "end": {"line": 172, "character": 51}}, "uri": "file://map.mli"}}, {"name": "exists", "kind": 12, "location": {"range": {"start": {"line": 166, "character": 4}, "end": {"line": 166, "character": 51}}, "uri": "file://map.mli"}}, {"name": "for_all", "kind": 12, "location": {"range": {"start": {"line": 160, "character": 4}, "end": {"line": 160, "character": 52}}, "uri": "file://map.mli"}}, {"name": "fold", "kind": 12, "location": {"range": {"start": {"line": 155, "character": 4}, "end": {"line": 155, "character": 57}}, "uri": "file://map.mli"}}, {"name": "iter", "kind": 12, "location": {"range": {"start": {"line": 149, "character": 4}, "end": {"line": 149, "character": 49}}, "uri": "file://map.mli"}}, {"name": "equal", "kind": 12, "location": {"range": {"start": {"line": 143, "character": 4}, "end": {"line": 143, "character": 57}}, "uri": "file://map.mli"}}, {"name": "compare", "kind": 12, "location": {"range": {"start": {"line": 139, "character": 4}, "end": {"line": 139, "character": 57}}, "uri": "file://map.mli"}}, {"name": "union", "kind": 12, "location": {"range": {"start": {"line": 125, "character": 4}, "end": {"line": 125, "character": 69}}, "uri": "file://map.mli"}}, {"name": "merge", "kind": 12, "location": {"range": {"start": {"line": 114, "character": 4}, "end": {"line": 115, "character": 77}}, "uri": "file://map.mli"}}, {"name": "remove", "kind": 12, "location": {"range": {"start": {"line": 107, "character": 4}, "end": {"line": 107, "character": 35}}, "uri": "file://map.mli"}}, {"name": "singleton", "kind": 12, "location": {"range": {"start": {"line": 101, "character": 4}, "end": {"line": 101, "character": 36}}, "uri": "file://map.mli"}}, {"name": "update", "kind": 12, "location": {"range": {"start": {"line": 88, "character": 4}, "end": {"line": 88, "character": 63}}, "uri": "file://map.mli"}}, {"name": "add", "kind": 12, "location": {"range": {"start": {"line": 79, "character": 4}, "end": {"line": 79, "character": 38}}, "uri": "file://map.mli"}}, {"name": "mem", "kind": 12, "location": {"range": {"start": {"line": 75, "character": 4}, "end": {"line": 75, "character": 32}}, "uri": "file://map.mli"}}, {"name": "is_empty", "kind": 12, "location": {"range": {"start": {"line": 72, "character": 4}, "end": {"line": 72, "character": 30}}, "uri": "file://map.mli"}}, {"name": "empty", "kind": 13, "location": {"range": {"start": {"line": 69, "character": 4}, "end": {"line": 69, "character": 19}}, "uri": "file://map.mli"}}, {"name": "t", "kind": 26, "location": {"range": {"start": {"line": 66, "character": 4}, "end": {"line": 66, "character": 16}}, "uri": "file://map.mli"}}, {"name": "key", "kind": 26, "location": {"range": {"start": {"line": 329, "character": 41}, "end": {"line": 329, "character": 57}}, "uri": "file://map.mli"}}, {"name": "new_loc", "kind": 12, "location": {"range": {"start": {"line": 73, "character": 0}, "end": {"line": 85, "character": 1}}, "uri": "file://"}}, {"name": "fill_sto_entry", "kind": 12, "location": {"range": {"start": {"line": 88, "character": 0}, "end": {"line": 90, "character": 1}}, "uri": "file://"}}, {"name": "fill_env_entry", "kind": 12, "location": {"range": {"start": {"line": 93, "character": 0}, "end": {"line": 95, "character": 1}}, "uri": "file://"}}, {"name": "eval_expr", "kind": 12, "location": {"range": {"start": {"line": 98, "character": 0}, "end": {"line": 994, "character": 1}}, "uri": "file://"}}, {"name": "sto", "kind": 13, "location": {"range": {"start": {"line": 997, "character": 0}, "end": {"line": 997, "character": 27}}, "uri": "file://"}}, {"name": "env", "kind": 13, "location": {"range": {"start": {"line": 998, "character": 0}, "end": {"line": 998, "character": 25}}, "uri": "file://"}}, {"name": "so", "kind": 13, "location": {"range": {"start": {"line": 999, "character": 0}, "end": {"line": 999, "character": 13}}, "uri": "file://"}}, {"name": "init_exp", "kind": 18, "location": {"range": {"start": {"line": 1001, "character": 0}, "end": {"line": 1008, "character": 1}}, "uri": "file://"}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re"},"range":{"start":{"line":6,"character":31},"end":{"line":6,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 4, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 5, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Stdlib, CamlinternalFormatBasics, Dune__exe, Str", "command": ""}}, {"range": {"start": {"line": 4, "character": 5}, "end": {"line": 4, "character": 9}}, "command": {"title": "31 uses. values: {read_cl_type_file} types: {exp_subparts [While, True, Times and 23 more], attr [AttrInit, Attr], binding [BindInit, Bind]}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":5}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0829696655273ms
Sending response {"id": 6, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Stdlib, CamlinternalFormatBasics, Dune__exe, Str", "command": ""}}, {"range": {"start": {"line": 4, "character": 5}, "end": {"line": 4, "character": 9}}, "command": {"title": "31 uses. values: {read_cl_type_file} types: {exp_subparts [While, True, Times and 23 more], attr [AttrInit, Attr], binding [BindInit, Bind]}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":6}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 7, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Stdlib, CamlinternalFormatBasics, Dune__exe, Str", "command": ""}}, {"range": {"start": {"line": 4, "character": 5}, "end": {"line": 4, "character": 9}}, "command": {"title": "31 uses. values: {read_cl_type_file} types: {exp_subparts [While, True, Times and 23 more], attr [AttrInit, Attr], binding [BindInit, Bind]}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":7}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/kim/Desktop/Notes/Programming_Languages/P5/interpreter.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0147819519043ms
Sending response {"id": 8, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Stdlib, CamlinternalFormatBasics, Dune__exe, Str", "command": ""}}, {"range": {"start": {"line": 4, "character": 5}, "end": {"line": 4, "character": 9}}, "command": {"title": "31 uses. values: {read_cl_type_file} types: {exp_subparts [While, True, Times and 23 more], attr [AttrInit, Attr], binding [BindInit, Bind]}", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":9,"method":"shutdown","params":null}
Sending response {"id": 9, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"exit","params":null}
Got exit! Terminating loop
Finished
